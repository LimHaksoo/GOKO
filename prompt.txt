
## 작업 {task}

### 배경 / 현재 코드베이스(반드시 반영)

프로젝트는 `apps/web`의 React + TypeScript + Vite 웹앱입니다. 현재는 “좌측 지도(Map) + 우측 캔버스(Canvas)” Split Layout이 있으나, **우측 캔버스가 placeholder** 수준이며, 내가 원하는 “지역 선택 → TourAPI 명소 로드 → 캔버스 배치 → 여행 만들기(자동 동선/이동수단 포함 일정 생성)” 기능이 없습니다.

현재 핵심 파일/구조(반드시 읽고 반영):

* `apps/web/src/components/layout/SplitView.tsx` : 좌측 `MapPanel`, 우측 `Canvas Panel (placeholder)` 구성
* `apps/web/src/components/features/map/MapPanel.tsx` :

  * Google Map + 한국 시도 GeoJSON을 표시
  * 시도 폴리곤 클릭 시 `useProvinceStore.selectProvince()`로 지역 선택 상태 업데이트
  * 현재는 `useBoardStore`의 `places`/`routeOrder` 기반으로 마커/폴리라인을 그림
* `apps/web/src/store/useBoardStore.ts` :

  * `placesById`, `routeOrder`, `ui(mapMode, canvasViewport)` 관리 + persist
  * `addPlace/removePlace/updatePlaceNotes/movePlace/reorderRoute/setMapMode/setCanvasViewport` 존재
  * 현재는 초기 샘플 place 3개가 들어있음(추후 import/replace 로직 필요)
* `apps/web/src/store/useProvinceStore.ts` :

  * `selectedProvince`, `selectedFeature`, `provincesGeo`, `provinceDensity` 관리
* `apps/web/src/shared/types/index.ts` : `Place` 타입(현재 `placeId`가 Google Place ID로 주석되어 있으나 TourAPI도 붙일 예정이면 확장/수정 필요)
* `apps/web/src/domain/route/haversine.ts` : 거리 계산 유틸(이걸 활용해 자동 정렬/이동시간 추정 로직을 만들 것)
* `apps/web/src/app/styles/globals.css` : `.place-node` 등 “노드 카드 UI” 스타일이 이미 존재(React Flow 노드로 재사용 권장)
* 의존성: React Flow가 이미 설치되어 있음(`reactflow`, `@reactflow/core`)

### 목표 기능(새로 구현)

1. **지역 선택 → TourAPI로 명소 불러오기**

* 사용자가 지도에서 시도(지역)를 선택하면, 선택한 지역에 해당하는 “명소/관광 컨텐츠” 목록을 **TourAPI 서비스키 기반으로 조회**한다.
* 조회 결과(명소 리스트)를 앱 상태에 저장하고, **오른쪽 캔버스에 카드/아이콘 형태(노드)로 자동 생성**한다.
* 최소 표시 정보: `이름(title)`, `주소(addr1)`, `좌표(mapx/mapy)`, (가능하면) `대표이미지(firstimage)`.

2. **캔버스에서 명소 노드 배치**

* 오른쪽 캔버스는 React Flow 기반의 무한 캔버스로 구현한다.
* 불러온 명소는 노드(Place Node)로 생성되어 드래그로 위치 이동 가능해야 한다.
* 노드에는 최소로 “메모(notes)” 편집이 가능해야 하며, 편집 내용은 `useBoardStore.updatePlaceNotes`로 저장한다.
* 노드의 드래그 이동은 `useBoardStore.movePlace`로 반영한다.
* (가능하면) 노드 삭제 버튼을 통해 해당 명소를 제외할 수 있게 한다(`useBoardStore.removePlace`).

3. **‘여행 만들기’ 버튼 → 자동 정렬 + 이동수단 포함 일정 생성**

* 캔버스 상단(또는 적절한 툴바)에 **“여행 만들기” 버튼**을 추가한다.
* 버튼 클릭 시:

  * 현재 캔버스에 존재하는 명소들(placesById)을 대상으로 **자동 동선 정렬(routeOrder 생성/업데이트)**을 수행한다.

    * 목표: 총 이동거리(대략) 최소화
    * 구현 제약: 외부 Directions API 없이도 동작하는 1차 MVP(= haversine 기반 휴리스틱)로 구현
    * 단, 향후 Google Directions 등으로 확장 가능하도록 설계를 분리(도메인 로직 계층)한다.
  * 정렬된 routeOrder를 기준으로 **이동수단(걷기/대중교통/차량/장거리 등)을 휴리스틱으로 추정**하고,
  * **여행 일정(Itinerary)**을 생성해 화면에 보여준다.

    * 예: 각 장소 방문 블록 + 장소 간 이동 블록(거리/예상 소요시간/이동수단)
    * 최소: 1일짜리 일정으로 생성(추후 multi-day 확장 가능하도록 데이터 구조를 설계)
* 생성된 routeOrder는 지도(MapPanel)와 동기화되어:

  * 마커 번호(1..N)가 정렬 순서대로 다시 표시되고
  * 폴리라인도 정렬 순서로 갱신되어야 한다.

4. **TourAPI 연동 방식/키 관리**

* `.env.example`에 TourAPI 서비스키 항목을 추가하고, 실제 코드는 `import.meta.env`에서 읽는다(Vite 규칙: `VITE_` prefix).
* 프론트에서 TourAPI를 직접 호출할 경우 발생 가능한 CORS/보안 이슈가 있으므로,

  * 개발 환경에서의 우회(예: Vite dev server proxy) 또는
  * 최소한의 “프록시 계층”을 설계안에 포함한다(구현 여부는 scope에서 판단).
* TourAPI 응답 파싱/에러 처리/로딩 상태가 사용자에게 보이도록 한다.

### UX 요구(최소)

* 지역 선택 직후: “로딩 중/에러/0건” 상태가 분명히 표시
* 성공 시: 캔버스에 N개의 노드 자동 생성 + 지도에도 동기화 반영
* “여행 만들기” 실행 후: itinerary UI가 노출되며, routeOrder가 갱신된 것이 보임
* 기존 지도 접기/펼치기(mapMode) 동작은 그대로 유지

### 기술/코드 품질 요구(반드시)

* domain 로직(UI 무관)과 UI 컴포넌트 분리
* 서비스 어댑터(`services/`)에 TourAPI 클라이언트 구현
* Zustand store는 역할 분리(예: TourAPI fetch state / Board state)
* 테스트 추가:

  * 최소 smoke: CanvasPanel 렌더 + 여행 만들기 버튼 존재
  * 핵심 유닛: route 최적화(정렬 결과), 이동수단 추정/일정 생성 로직
* 타입 안정성: TourAPI 응답 타입 정의(최소 필요한 필드만)

---